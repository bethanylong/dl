#!/usr/bin/env python

import curses
import time
import threading
import sys
import click

def read_train(filename='train.txt'):
    with open(filename) as fh:
        return fh.readlines()

def beep():
    sys.stdout.write('\a')
    sys.stdout.flush()

def bell(train_thr):
    while train_thr.is_alive():
        beep()
        time.sleep(0.5)

def train(obstacle=None):
    try:
        curses.wrapper(curses_train, obstacle)
    except KeyboardInterrupt:
        # You fool.
        pass

def put_in_box(text):
    top_and_bottom = '+' + '-' * (len(text) + 2) + '+'
    middle = '| ' + text + ' |'
    return [top_and_bottom, middle, top_and_bottom]

def render_obstacle(stdscr, obstacle, y=13, x=5):
    max_y, max_x = stdscr.getmaxyx()
    box_text = put_in_box(obstacle)
    for line_offset, line in enumerate(box_text):
        stdscr.addstr(y + line_offset, x, line[:max_x - x])

def render_exhaust(stdscr, train_progress, base_y):
    """Fill y-space above train with hyper-realistic exhaust."""
    max_y, max_x = stdscr.getmaxyx()
    exh_left = 23  # Begin exhaust on F59 sprite
    exh_right = 43 # End exhaust on F59 sprite

    # TODO
    pass

def curses_train(stdscr, obstacle):
    max_y, max_x = stdscr.getmaxyx()
    curses.curs_set(0)

    #bad_train = "#####"
    good_train = read_train()
    y = 10
    x = 5

    debris_x = 50
    debris_y = 15
    debris_spread = 5
    
    if obstacle:
        render_obstacle(stdscr, obstacle)
        stdscr.refresh()

    train_len = max([len(line) for line in good_train])
    for train_progress in reversed(range(-train_len, max_x)):
        #stdscr.addstr(y, train_progress, good_train)

        for y_offset, line in enumerate(good_train):
            if train_progress >= 0:
                x_index = train_progress
                line_part = line[0 : max_x - train_progress]
            else:
                # Simulate drawing off end of screen
                x_index = 0
                line_part = line[-train_progress : max_x - train_progress]

            # Draw one line of train, without awkward blocky spaces at beginning (pretty collisions!)
            left_stripped_line_part = line_part.lstrip()
            left_length_difference = len(line_part) - len(left_stripped_line_part)
            if x_index + left_length_difference >= max_x:
                continue
            stdscr.addstr(y + y_offset, x_index + left_length_difference, left_stripped_line_part)

        stdscr.refresh()
        time.sleep(0.02)

@click.command()
@click.option('--obstacle', '-o')
def main(obstacle):
    train_thr = threading.Thread(target=train, args=[obstacle])
    bell_thr = threading.Thread(target=bell, args=[train_thr])

    train_thr.start()
    bell_thr.start()

if __name__ == '__main__':
    main()
